# 2D Wave Simulation with Non-Homogeneous Media

## Описание

Данная программа решает двумерное волновое уравнение в неоднородной среде с переменными параметрами:
- **ρ(x,y)** - плотность среды
- **K(x,y)** - модуль объёмного сжатия (bulk modulus)

## Физическая модель

### Волновое уравнение

Для неоднородной среды волновое уравнение имеет вид:

```
ρ(x,y) * ∂²p/∂t² = ∇·(K(x,y)∇p) - β*ρ*∂p/∂t + источник
```

где:
- `p` - давление
- `ρ(x,y)` - пространственно-зависимая плотность
- `K(x,y)` - пространственно-зависимый модуль объёмного сжатия
- `β` - коэффициент демпфирования (поглощение)
- `∇·(K∇p)` - дивергенция градиента с переменным коэффициентом

### Связь K и скорости звука

Локальная скорость звука связана с параметрами среды:

```
c(x,y)² = K(x,y) / ρ(x,y)
```

## Реализация

### 1. Неоднородная плотность ρ(x,y)

```python
# Создаём массив плотности для всей области
rho = np.ones((n, n)) * 1200  # По умолчанию высокая плотность

# В области вблизи границы (поглощающий слой) устанавливаем низкую плотность
mask_absorb = dist < L_abs / 3
rho[mask_absorb] = 800
```

**Ключевые моменты:**
- `rho` - это двумерный массив размера (n, n)
- Каждому узлу сетки присваивается своё значение плотности
- В исходном коде была ошибка: использовалось `if dist.any() < L_abs / 3`, что неверно для массивов

### 2. Модуль объёмного сжатия K(x,y)

```python
# Bulk modulus связан со скоростью звука: c² = K/ρ
K = np.ones((n, n)) * (c**2 * 1200)  # По умолчанию K = c² * ρ₀

# Создадим неоднородность в центре области
dist_from_center = np.sqrt((X - center_x)**2 + (Y - center_y)**2)
mask_inhomo = dist_from_center < radius
K[mask_inhomo] = (c * 1.2)**2 * 1000  # Область с увеличенной скоростью
```

**Возможности:**
- Можно задавать произвольные неоднородности
- Круглые включения с другой скоростью звука
- Слоистые структуры
- Градиентные изменения свойств

### 3. Вычисление оператора ∇·(K∇p)

Для неоднородной среды нельзя просто использовать лапласиан. Нужно вычислять:

```python
# 1. Градиент давления
grad_p_x[1:-1, :] = (p[2:, :] - p[:-2, :]) / (2 * dx)
grad_p_y[:, 1:-1] = (p[:, 2:] - p[:, :-2]) / (2 * dx)

# 2. Умножение на K
K_grad_p_x = K * grad_p_x
K_grad_p_y = K * grad_p_y

# 3. Дивергенция
div_K_grad_p[1:-1, :] += (K_grad_p_x[2:, :] - K_grad_p_x[:-2, :]) / (2 * dx)
div_K_grad_p[:, 1:-1] += (K_grad_p_y[:, 2:] - K_grad_p_y[:, :-2]) / (2 * dx)
```

### 4. Обновление поля давления

```python
# Скорость изменения давления (для демпфирования)
dp_dt = (p - p_prev) / dt

# Временная производная второго порядка
d2p_dt2 = div_K_grad_p / rho - beta * dp_dt + source / rho

# Схема leap-frog
p_next = 2*p - p_prev + dt**2 * d2p_dt2
```

## Параметры

- `length = 200` - размер области (м)
- `c = 340` - базовая скорость звука (м/с)
- `nu = 25` - частота источника (Гц)
- `n = 200` - количество узлов по каждому направлению
- `n_t = 800` - количество временных шагов

## Запуск

```bash
python wave_simulation_2d.py
```

## Визуализация

Программа создаёт два графика:
1. **Волновое поле** - показывает распространение волн в реальном времени
2. **Распределение плотности** - показывает структуру среды

## Возможные расширения

1. **Многослойная среда**: создание горизонтальных или вертикальных слоёв
2. **Случайные неоднородности**: добавление шума к K(x,y) и ρ(x,y)
3. **Анизотропия**: различные скорости в разных направлениях
4. **Вязкоупругость**: частотно-зависимое затухание
5. **Множественные источники**: несколько источников волн

## Физические эффекты

При распространении волн через неоднородности можно наблюдать:
- **Отражение** на границах раздела сред
- **Преломление** при изменении скорости звука
- **Дифракцию** на неоднородностях
- **Рассеяние** на мелких включениях
