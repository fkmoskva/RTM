# Сравнение: НЕПРАВИЛЬНАЯ vs ПРАВИЛЬНАЯ реализация

## ❌ НЕПРАВИЛЬНЫЙ подход (из исходного кода)

```python
# ОШИБКА 1: неправильное использование dist.any()
if dist.any() < L_abs / 3:
    rho = 800
else: 
    rho = 1200
```

**Проблемы:**
1. `dist.any()` возвращает `True` если хотя бы один элемент != 0, это не имеет смысла для сравнения
2. `rho` становится скаляром (одно число), а не массивом
3. В уравнении используется деление на `rho`, что приводит к одинаковому значению для всех узлов

**Результат:**
```python
type(rho) = <class 'int'>  # Это скаляр!
```

## ✅ ПРАВИЛЬНЫЙ подход

```python
# Создаём 2D массив плотности
rho = np.ones((n, n)) * 1200  # Базовая плотность

# Создаём маску для областей вблизи границы
mask_absorb = dist < L_abs / 3

# Присваиваем другую плотность в поглощающем слое
rho[mask_absorb] = 800
```

**Преимущества:**
1. `rho` - двумерный массив размера (n, n)
2. Каждому узлу сетки присвоено своё значение
3. Можно создавать сложные пространственные распределения

**Результат:**
```python
type(rho) = <class 'numpy.ndarray'>
rho.shape = (200, 200)
```

---

## Волновое уравнение в неоднородной среде

### Для однородной среды (упрощённое):
```
∂²p/∂t² = c² ∇²p
```

### Для неоднородной среды (правильное):
```
ρ(x,y) * ∂²p/∂t² = ∇·(K(x,y)∇p)
```

где:
- `K(x,y) = c(x,y)² * ρ(x,y)` - модуль объёмного сжатия
- `c(x,y)` - локальная скорость звука

---

## Численная реализация оператора ∇·(K∇p)

### ❌ НЕПРАВИЛЬНО (как в исходном коде):
```python
# Это работает только для ОДНОРОДНОЙ среды!
laplacian = np.zeros_like(p)
laplacian[1:-1, 1:-1] = d2x[:,1:-1] + d2y[1:-1,:]
result = c**2 * laplacian
```

### ✅ ПРАВИЛЬНО для неоднородной среды:
```python
# Шаг 1: Градиент давления
grad_p_x[1:-1, :] = (p[2:, :] - p[:-2, :]) / (2 * dx)
grad_p_y[:, 1:-1] = (p[:, 2:] - p[:, :-2]) / (2 * dx)

# Шаг 2: K∇p
K_grad_p_x = K * grad_p_x
K_grad_p_y = K * grad_p_y

# Шаг 3: ∇·(K∇p)
div_K_grad_p[1:-1, :] += (K_grad_p_x[2:, :] - K_grad_p_x[:-2, :]) / (2 * dx)
div_K_grad_p[:, 1:-1] += (K_grad_p_y[:, 2:] - K_grad_p_y[:, :-2]) / (2 * dx)
```

---

## Почему это важно?

1. **Физическая корректность**: Волны ведут себя по-разному в средах с разными свойствами
2. **Отражения и преломления**: На границах сред с разными K и ρ возникают отражённые и преломлённые волны
3. **Точность моделирования**: Реальные среды (горные породы, ткани, материалы) всегда неоднородны

---

## Пример использования

Смотрите файлы:
- `wave_simulation_2d.py` - полная рабочая симуляция
- `example_correct_implementation.py` - демонстрация ключевых концепций
- `README_wave_simulation.md` - подробная документация
